import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { emissive } from 'three/tsl';
const scene=new THREE.Scene();

function project1() {
    //Setting scene, camera and renderer
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 0, 2500);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    renderer.shadowMap.enabled = true;
    const controls = new OrbitControls(camera, renderer.domElement);

    function helper(light) {
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        light.shadow.camera.top = 600;
        light.shadow.camera.bottom = -600;
        light.shadow.camera.left = -600;
        light.shadow.camera.right = 600;
        light.shadow.camera.near = 0.1;
        light.shadow.camera.far = 3000;
    }

    const directionalLight2 = new THREE.DirectionalLight( "white", 1 );
    directionalLight2.castShadow = true;
    directionalLight2.position.set(0, 600,-500);
    helper(directionalLight2);
    scene.add(directionalLight2);

    const directionalLight1 = new THREE.DirectionalLight( "white", 1 );
    directionalLight1.castShadow = true;
    directionalLight1.position.set(0, 600,500);
    helper(directionalLight1);
    scene.add(directionalLight1);

    const directionalLight3 = new THREE.DirectionalLight( "white", 1 );
    directionalLight3.castShadow = true;
    directionalLight3.position.set(500, 500,0);
    helper(directionalLight3);
    scene.add(directionalLight3);

    const directionalLight4 = new THREE.DirectionalLight( "white", 1 );
    directionalLight4.castShadow = true;
    directionalLight4.position.set(-500, 500,0);
    helper(directionalLight4);
    scene.add(directionalLight4);

    const plane = new THREE.PlaneGeometry(2500, 2500, 3);
    const planeMaterial = new THREE.MeshStandardMaterial({ color: "gray", side: THREE.DoubleSide });
    const planeMesh = new THREE.Mesh(plane, planeMaterial);
    scene.add(planeMesh);
 planeMesh.rotation.set(Math.PI / 2, 0, 0);
    planeMesh.position.set(0, -550, 0);
    planeMesh.receiveShadow = true;

    let parentWidth = 100, parentHeight = 800;
    if (parentWidth < 100) parentWidth = 100;
    if (parentHeight < 800) parentHeight = 800;
    let biasing = 10;
    let changedParentWidth = (parentWidth - 100) / 2;
    let changedParentHeight = parentHeight - 900;
    let keyHoleMid = 50;
    //#region Handle BackPlate
    const parentShape = new THREE.Shape();
    parentShape.moveTo(0, 0);
    parentShape.absarc(parentWidth / 2, 0, parentWidth / 2, Math.PI, Math.PI * 2, false);
    parentShape.lineTo(parentWidth, parentHeight);
    parentShape.absarc(parentWidth / 2, parentHeight, parentWidth / 2, 0, Math.PI, false);
    parentShape.lineTo(0, 0);

    const keyHoleWidth = 33.33, keyHoleHeight = 200;
    const keyHoleShape = new THREE.Shape();
    keyHoleShape.moveTo(-keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight);
    keyHoleShape.absarc(keyHoleMid + changedParentWidth, keyHoleHeight, keyHoleWidth / 2, Math.PI, Math.PI * 2, false);
    keyHoleShape.lineTo(keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight);
    keyHoleShape.lineTo(keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight + 100 - biasing);
    keyHoleShape.absarc(keyHoleMid + changedParentWidth, keyHoleHeight + 100, keyHoleWidth / 2 + biasing, 0, Math.PI, false);
    keyHoleShape.lineTo(-keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight + 100 - biasing);
    keyHoleShape.lineTo(-keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight);
    parentShape.holes.push(keyHoleShape);
    const extrudeSettings = {
        depth: 50,
        bevelEnabled: false
    };
    const parentGeometry = new THREE.ExtrudeGeometry(parentShape, extrudeSettings);
    const parentMaterial = new THREE.MeshStandardMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const parentMesh = new THREE.Mesh(parentGeometry, parentMaterial);
    scene.add(parentMesh);
    parentMesh.castShadow = true;
    parentMesh.receiveShadow=true;
    parentMesh.rotation.set(0,0,0)

    const parentEdges = new THREE.EdgesGeometry(parentGeometry);
    const parentEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const parentEdgesMesh = new THREE.LineSegments(parentEdges, parentEdgesMaterial);
    parentMesh.add(parentEdgesMesh);
    //#endregion

    //#region Handle Geometry
    let handleWidth = 100;
    const handlePoints = [
        new THREE.Vector3(0, 0 - changedParentWidth, -50),
        new THREE.Vector3(0, 0 - changedParentWidth, 0),
        new THREE.Vector3(-handleWidth, 0 - changedParentWidth, 0),
        new THREE.Vector3(-handleWidth, 900 - 100 + changedParentWidth + changedParentHeight, 0),
        new THREE.Vector3(0, 900 - 100 + changedParentWidth + changedParentHeight, 0),
        new THREE.Vector3(0, 900 - 100 + changedParentWidth + changedParentHeight, -50)
    ];
    const handlePath = new THREE.CatmullRomCurve3(handlePoints);
    const handleGeometry = new THREE.TubeGeometry(
        handlePath,
        100,
        20,
        8,
        false
    );
    const material = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, roughness: 0.2, emissive: "gray" });
    const handleMesh = new THREE.Mesh(handleGeometry, material);
    handleMesh.position.set(parentWidth / 2, 50, 100);
    handleMesh.castShadow=true;
    handleMesh.receiveShadow=true;
    parentMesh.add(handleMesh);

    const handleEdges = new THREE.EdgesGeometry(handleGeometry);
    const handleEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const handleEdgesMesh = new THREE.LineSegments(handleEdges, handleEdgesMaterial);
    //handleMesh.add(handleEdgesMesh);

    function rotateHandle(isHandleRotated) {
        if (isHandleRotated) {
            handleMesh.rotation.set(Math.PI, -Math.PI, 0);
            handleMesh.position.set(parentWidth / 2, parentHeight - 50, 100);
        }
    }

    rotateHandle(false);
    //#endregion

    //#region knob Geometry
    let knobHeight = 450;
    const knob = new THREE.Shape();
    knob.moveTo(keyHoleMid - 20 + changedParentWidth, 0);
    knob.absarc(keyHoleMid + changedParentWidth, 0, 20, Math.PI, Math.PI * 2, false);
    knob.lineTo(keyHoleMid + 20 + changedParentWidth, 0);
    knob.lineTo(keyHoleMid + 20 + biasing + changedParentWidth, 200);
    knob.absarc(keyHoleMid + changedParentWidth, 200, keyHoleMid / 2 + biasing / 2, 0, Math.PI, false);
    knob.lineTo(keyHoleMid - 20 - biasing + changedParentWidth, 200);
    knob.lineTo(keyHoleMid - 20 + changedParentWidth, 0);

    const knobSettings = {
        depth: 50,
        bevelEnabled: false
    };

    const knobGeometry = new THREE.ExtrudeGeometry(knob, knobSettings);
    const knobMaterial = new THREE.MeshPhysicalMaterial({ color: "red", side: THREE.DoubleSide, emissive: "red" });
    const knobMesh = new THREE.Mesh(knobGeometry, knobMaterial);
    knobMesh.position.set(0, knobHeight, 50);
    knobMesh.castShadow=true;
    parentMesh.add(knobMesh);
    parentMesh.position.set(0, -400, 0);

    const knobEdges = new THREE.EdgesGeometry(knobGeometry);
    const knobEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const knobEdgesMesh = new THREE.LineSegments(knobEdges, knobEdgesMaterial);
    knobMesh.add(knobEdgesMesh);
    //#endregion

    // Animating the shape
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
}

function getBackPlateHeight() {
    return 300;
}

function getBackPlateWidth() {
    return 100;
}

function getHandleHeight() {
    return 240;
}

function getHandleWidth() {
    return 140;
}
const origin = new THREE.Vector3(0, 0);

function getBackPlate(parentObj) {
    const backPlateHeight = getBackPlateHeight(), backPlateWidth = getBackPlateWidth();
    const backPlate = new THREE.Shape();
    backPlate.moveTo(0 + origin.x, 0 + origin.y);
    backPlate.lineTo(backPlateWidth / 3 + origin.x, 0 + origin.y);
    backPlate.lineTo(backPlateWidth / 3 + origin.x, (3 * backPlateHeight - 2 * backPlateWidth) / 6 - backPlateWidth / 3 + origin.y);
    backPlate.absarc(backPlateWidth / 3 + origin.x, (3 * backPlateHeight - 2 * backPlateWidth) / 6 + (backPlateWidth / 3) + origin.y, 2 * backPlateWidth / 3, Math.PI * 1.5, Math.PI / 2, false);
    backPlate.lineTo(backPlateWidth / 3 + origin.x, backPlateHeight - (3 * backPlateHeight - 2 * backPlateWidth) / 6 + backPlateWidth / 3 + origin.y);
    backPlate.lineTo(backPlateWidth / 3 + origin.x, backPlateHeight + origin.y);
    backPlate.lineTo(0 + origin.x, backPlateHeight + origin.y);
    backPlate.lineTo(0 + origin.x, 0 + origin.y);
    const backPlateTopHole = new THREE.Path();
    backPlateTopHole.absarc(backPlateWidth / 6 + origin.x, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y, backPlateWidth / 12, 0, Math.PI * 2, false);
    backPlate.holes.push(backPlateTopHole);

    const backPlateBottomHole = new THREE.Path();
    backPlateBottomHole.absarc(backPlateWidth / 6 + origin.x, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y, backPlateWidth / 12, 0, Math.PI * 2, false);
    backPlate.holes.push(backPlateBottomHole);

    const backPlateSettings = {
        depth: 30,
        bevelEnabled: false
    };

    const backPlateGeometry = new THREE.ExtrudeGeometry(backPlate, backPlateSettings);
    const backPlateMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const backPlateMesh = new THREE.Mesh(backPlateGeometry, backPlateMaterial);

    const backPlateEdges = new THREE.EdgesGeometry(backPlateGeometry);
    const backPlateEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const backPlateEdgesMesh = new THREE.LineSegments(backPlateEdges, backPlateEdgesMaterial);
    backPlateMesh.add(backPlateEdgesMesh);

    parentObj.add(backPlateMesh);
    backPlateMesh.castShadow=true;
    backPlateMesh.receiveShadow=true;


    const topHoleCircle = new THREE.Shape();
    topHoleCircle.absarc(backPlateWidth / 6 + origin.x, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y, backPlateWidth / 12, 0, Math.PI * 2, false);

    const topHoleCircleSettings = {
        depth: 2,
        bevelEnabled: false
    };

    const topHole = new THREE.Path();
    topHole.moveTo(backPlateWidth / 6 + origin.x, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);
    topHole.lineTo(backPlateWidth / 6 + origin.x, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y - 4);
    topHole.lineTo(backPlateWidth / 6 + origin.x + 2, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y - 4);
    topHole.lineTo(backPlateWidth / 6 + origin.x + 2, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);
    topHole.lineTo(backPlateWidth / 6 + origin.x + 6, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);
    topHole.lineTo(backPlateWidth / 6 + origin.x + 6, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 2);
    topHole.lineTo(backPlateWidth / 6 + origin.x + 2, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 2);
    topHole.lineTo(backPlateWidth / 6 + origin.x + 2, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 6);
    topHole.lineTo(backPlateWidth / 6 + origin.x, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 6);
    topHole.lineTo(backPlateWidth / 6 + origin.x, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 2);
    topHole.lineTo(backPlateWidth / 6 + origin.x - 4, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 2);
    topHole.lineTo(backPlateWidth / 6 + origin.x - 4, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);
    topHole.lineTo(backPlateWidth / 6 + origin.x, backPlateHeight - (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);

    topHoleCircle.holes.push(topHole);

    const topHoleCircleGeometry = new THREE.ExtrudeGeometry(topHoleCircle, topHoleCircleSettings);
    const topHoleCircleMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive:"gray" });
    const topHoleCircleMesh = new THREE.Mesh(topHoleCircleGeometry, topHoleCircleMaterial);
    backPlateMesh.add(topHoleCircleMesh);
    topHoleCircleMesh.castShadow=true;
    topHoleCircleMesh.receiveShadow=true;

    topHoleCircleMesh.position.set(0, 0, 30);

    const bottomHoleCircle = new THREE.Shape();
    bottomHoleCircle.absarc(backPlateWidth / 6 + origin.x, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y, backPlateWidth / 12, 0, Math.PI * 2, false);

    const bottomHoleCircleSettings = {
        depth: 2,
        bevelEnabled: false
    };

    const bottomHole = new THREE.Path();
    bottomHole.moveTo(backPlateWidth / 6 + origin.x, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y - 4);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x + 2, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y - 4);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x + 2, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);//
    bottomHole.lineTo(backPlateWidth / 6 + origin.x + 6, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x + 6, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 2);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x + 2, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 2);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x + 2, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 6);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 6);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 2);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x - 4, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y + 2);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x - 4, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);
    bottomHole.lineTo(backPlateWidth / 6 + origin.x, (backPlateHeight / 16 + backPlateWidth / 12) + origin.y);

    bottomHoleCircle.holes.push(bottomHole);

    const bottomHoleCircleGeometry = new THREE.ExtrudeGeometry(bottomHoleCircle, bottomHoleCircleSettings);
    const bottomHoleCircleMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const bottomHoleCircleMesh = new THREE.Mesh(bottomHoleCircleGeometry, bottomHoleCircleMaterial);
    backPlateMesh.add(bottomHoleCircleMesh);
    bottomHoleCircleMesh.castShadow=true;
    bottomHoleCircleMesh.receiveShadow=true;

    bottomHoleCircleMesh.position.set(0, 0, 30);
    return backPlateMesh;
}


function getHandle(parentObj) {
    const backPlateMesh = getBackPlate(parentObj);
    const backPlateHeight = getBackPlateHeight(), backPlateWidth = getBackPlateWidth();
    const cockspurHeight = getHandleHeight(), cockspurWidth = getHandleWidth(), biasing = 20;
    const cockspurTopConnector = new THREE.Shape();
    cockspurTopConnector.moveTo(0 + origin.x, 0 + origin.y);
    cockspurTopConnector.bezierCurveTo(0 + origin.x, 0 + origin.y, 0 + origin.x, cockspurHeight / 6 + origin.y, -2 * biasing + origin.x, cockspurHeight / 6 + origin.y);
    //cockspur.quadraticCurveTo(0, cockspurHeight/6, -2*biasing, cockspurHeight/6);
    //cockspur.lineTo(-2*biasing+origin.x,cockspurHeight/6+origin.y);
    // cockspurTopConnector.bezierCurveTo(-2 * biasing + origin.x, cockspurHeight / 6 + origin.y, -6 * biasing + origin.x, cockspurHeight / 3 + origin.y, -cockspurWidth + (2 * biasing) + origin.x, cockspurHeight / 3 + origin.y);
    cockspurTopConnector.bezierCurveTo(-cockspurWidth + (2 * biasing) + origin.x, cockspurHeight / 3 + origin.y, -cockspurWidth + origin.x, cockspurHeight / 3 + (2 * biasing) + origin.y, -3 * biasing + origin.x, cockspurHeight / 3 + (3 * biasing) + origin.y);
    cockspurTopConnector.bezierCurveTo(-2 * biasing + origin.x, cockspurHeight / 3 + (3 * biasing) + origin.y, 0 + origin.x, (5 * cockspurHeight) / 6 + origin.y, cockspurWidth / 2 + origin.x, (4 * cockspurHeight) / 6 + origin.y);
    cockspurTopConnector.bezierCurveTo(cockspurWidth / 2 + origin.x, (4 * cockspurHeight) / 6 + origin.y, cockspurWidth + origin.x, cockspurHeight / 3 + origin.y, cockspurWidth + origin.x - 40, 0 + origin.y);
    cockspurTopConnector.lineTo(0 + origin.x, 0 + origin.y);

    const cockspurTopConnectorSettings = {
        depth: 30,
        bevelEnabled: false
    };

    const cockspurGeometry = new THREE.ExtrudeGeometry(cockspurTopConnector, cockspurTopConnectorSettings);
    const cockspurMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const cockspurMesh = new THREE.Mesh(cockspurGeometry, cockspurMaterial);
    parentObj.add(cockspurMesh);
    cockspurMesh.castShadow=true;
    cockspurMesh.receiveShadow=true;
    //backPlate.add(cockspurMesh);

    const cockspurEdges = new THREE.EdgesGeometry(cockspurGeometry);
    const cockspurEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const cockspurEdgesMesh = new THREE.LineSegments(cockspurEdges, cockspurEdgesMaterial);
    cockspurMesh.add(cockspurEdgesMesh);

    cockspurMesh.position.set(backPlateWidth / 2, 35 + (240 - cockspurHeight) / 2 + (backPlateHeight - 300) / 2, 30);

    const cockspurHandleWidth = 30, cockspurHandleHeight = cockspurHeight * 3, shifting = 80;
    const cockspurMiddleConnector = new THREE.Shape();
    cockspurMiddleConnector.moveTo(0 + origin.x, 0 + origin.y);
    cockspurMiddleConnector.lineTo(0 + origin.x, -4 * biasing + origin.y + shifting);
    cockspurMiddleConnector.quadraticCurveTo(+2 * biasing + origin.x, -8 * biasing + origin.y, 0 + origin.x + 2 * biasing, -12 * biasing + origin.y);
    cockspurMiddleConnector.lineTo(0 + origin.x + 2 * biasing, -cockspurHandleHeight + origin.y);
    //cockspurHandle.absarc(cockspurHandleWidth/2+origin.x+2*biasing, -cockspurHandleHeight+origin.y, cockspurHandleWidth/2, Math.PI, Math.PI*2, false);
    cockspurMiddleConnector.lineTo(cockspurHandleWidth + origin.x + 2 * biasing, -cockspurHandleHeight + origin.y);
    cockspurMiddleConnector.lineTo(cockspurHandleWidth + origin.x + 2 * biasing, -240 + origin.y);
    cockspurMiddleConnector.bezierCurveTo(cockspurHandleWidth + origin.x + 2 * biasing, -240 + origin.y, cockspurHandleWidth + 2 * biasing + origin.x, -180 + origin.y, cockspurHandleWidth + origin.x, -80 + origin.y + shifting);
    cockspurMiddleConnector.lineTo(cockspurHandleWidth + origin.x, 0 + origin.y);
    cockspurMiddleConnector.lineTo(0 + origin.x, 0 + origin.y);

    const cockspurHandleSettings = {
        depth: cockspurWidth - 40,
        bevelEnabled: false
    };

    const cockspurHandleGeometry = new THREE.ExtrudeGeometry(cockspurMiddleConnector, cockspurHandleSettings);
    const cockspurHandleMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const cockspurHandleMesh = new THREE.Mesh(cockspurHandleGeometry, cockspurHandleMaterial);
    cockspurMesh.add(cockspurHandleMesh);
    cockspurHandleMesh.castShadow=true;
    cockspurHandleMesh.receiveShadow=true;

    const cockspurHandleEdges = new THREE.EdgesGeometry(cockspurHandleGeometry);
    const cockspurHandleEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const cockspurHandleEdgesMesh = new THREE.LineSegments(cockspurHandleEdges, cockspurHandleEdgesMaterial);
    cockspurHandleMesh.add(cockspurHandleEdgesMesh);

    cockspurHandleMesh.rotation.set(0, 3 * Math.PI / 2, 0);
    cockspurHandleMesh.position.set(cockspurWidth - 40 + origin.x, 0, 0 - origin.x);

    const cap = new THREE.SphereGeometry(cockspurHandleHeight / 14, 32, 16, 0, Math.PI, 0, Math.PI);
    const curveConnectorMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const curveConnectorMesh = new THREE.Mesh(cap, curveConnectorMaterial);
    cockspurMesh.add(curveConnectorMesh);
    curveConnectorMesh.castShadow=true;
    curveConnectorMesh.receiveShadow=true;

    const curveConnectorEdges = new THREE.EdgesGeometry(cap);
    const curveConnectorEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const curveConnectorEdgesMesh = new THREE.LineSegments(curveConnectorEdges, curveConnectorEdgesMaterial);
    curveConnectorMesh.add(curveConnectorEdgesMesh);

    curveConnectorMesh.position.set((cockspurWidth / 2) + origin.x - 40, (cockspurHeight / 2) + origin.y, 10);

    const cockspurBottomConnector = new THREE.Shape();
    cockspurBottomConnector.absarc(0, 0, (cockspurWidth - 40) / 2, 0, Math.PI, false);

    const handleBaseSettings = {
        depth: 30,
        bevelEnabled: false
    };

    const handleBaseGeometry = new THREE.ExtrudeGeometry(cockspurBottomConnector, handleBaseSettings);
    const handleBaseMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const handleBaseMesh = new THREE.Mesh(handleBaseGeometry, handleBaseMaterial);
    cockspurMesh.add(handleBaseMesh);
    handleBaseMesh.castShadow=true;
    handleBaseMesh.receiveShadow=true;

    const handleBaseEdges = new THREE.EdgesGeometry(handleBaseGeometry);
    const handleBaseEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const handleBaseEdgesMesh = new THREE.LineSegments(handleBaseEdges, handleBaseEdgesMaterial);
    handleBaseMesh.add(handleBaseEdgesMesh);

    handleBaseMesh.position.set((cockspurWidth - 40) / 2 + origin.x, -cockspurHandleHeight + origin.y, 40);
    handleBaseMesh.rotation.set(0, 0, -Math.PI);
    // parentObj.remove(backPlateMesh);

    function rotateHandle(isHandleRotated) {
        if (isHandleRotated === "left") {
            //parentObj.remove(backPlateMesh);
            backPlateMesh.rotation.set(0, Math.PI, 0);
            backPlateMesh.position.set(backPlateWidth, 0, 30);
            let cockspurHandleWorldPosition = new THREE.Vector3();
            let curveConnectorWorldPosition = new THREE.Vector3();
            let handleBaseWorldPosition = new THREE.Vector3();
            cockspurHandleMesh.getWorldPosition(cockspurHandleWorldPosition);
            curveConnectorMesh.getWorldPosition(curveConnectorWorldPosition);
            handleBaseMesh.getWorldPosition(handleBaseWorldPosition);
            cockspurMesh.remove(cockspurHandleMesh);
            scene.add(cockspurHandleMesh);
            cockspurMesh.remove(curveConnectorMesh);
            scene.add(curveConnectorMesh);
            cockspurMesh.remove(handleBaseMesh);
            scene.add(handleBaseMesh);
            // cockspurHandleMesh.position.set(cockspurHandleWorldPosition.x+origin.x, cockspurHandleWorldPosition.y+origin.y, cockspurHandleWorldPosition.z);
            // curveConnectorMesh.position.set(curveConnectorWorldPosition.x+origin.x,curveConnectorWorldPosition.y+origin.y,curveConnectorWorldPosition.z);
            // handleBaseMesh.position.set(handleBaseWorldPosition.x+origin.x, handleBaseWorldPosition.y+origin.y, handleBaseWorldPosition.z);
            cockspurMesh.rotation.set(0, Math.PI, 0);
            cockspurMesh.position.set(cockspurWidth - 80 + origin.x, 0 + 30 + origin.y, 60);
            curveConnectorMesh.position.set(30 + origin.x, 140 + origin.y, 60);
            cockspurHandleMesh.position.set(cockspurWidth - 80 + origin.x, 0 + 30, 30, 100 + origin.y);
            handleBaseMesh.position.set((cockspurWidth - 40) / 2 + origin.x - 40, -cockspurHandleHeight + origin.y + 30, 70);

        }
    }

    rotateHandle("right");
}

function project3() {
    //Setting scene, camera and renderer
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 0, 1200);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    renderer.shadowMap.enabled=true;
    const controls = new OrbitControls(camera, renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 1);
    //scene.add(ambientLight);


    function helper(light) {
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        light.shadow.camera.top = 900;
        light.shadow.camera.bottom = -900;
        light.shadow.camera.left = -900;
        light.shadow.camera.right = 900;
        light.shadow.camera.near = 0.1;
        light.shadow.camera.far = 5000;
    }

    const directionalLight2 = new THREE.DirectionalLight( "white", 1 );
    directionalLight2.castShadow = true;
    directionalLight2.position.set(0, 600,-500);
    helper(directionalLight2);
    scene.add(directionalLight2);

    const directionalLight1 = new THREE.DirectionalLight( "white", 1 );
    directionalLight1.castShadow = true;
    directionalLight1.position.set(0, 600,500);
    helper(directionalLight1);
    scene.add(directionalLight1);

    const directionalLight3 = new THREE.DirectionalLight( "white", 1 );
    directionalLight3.castShadow = true;
    directionalLight3.position.set(500, 500,0);
    helper(directionalLight3);
    scene.add(directionalLight3);

    const directionalLight4 = new THREE.DirectionalLight( "white", 1 );
    directionalLight4.castShadow = true;
    directionalLight4.position.set(-500, 500,0);
    helper(directionalLight4);
    scene.add(directionalLight4);

    const plane = new THREE.PlaneGeometry(2500, 2500, 3);
    const planeMaterial = new THREE.MeshStandardMaterial({ color: "gray", side: THREE.DoubleSide });
    const planeMesh = new THREE.Mesh(plane, planeMaterial);
    scene.add(planeMesh);
 planeMesh.rotation.set(Math.PI / 2, 0, 0);
    planeMesh.position.set(0, -850, 0);
    planeMesh.receiveShadow = true;



    const origin = new THREE.Vector2(0, 0);
    const parentObj = new THREE.Object3D();
    scene.add(parentObj);


    const backPlateHeight = getBackPlateHeight(), backPlateWidth = getBackPlateWidth();
    //#region  Back Plate
    //const backPlateMesh = getBackPlate(parentObj);
    //#endregion

    //#region  Cock Spur Handle
    getHandle(parentObj);
    //#endregion



    //rotateHandle("right");

    // Animating the shape
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
}


function project2() {
    //Setting scene, camera and renderer
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 0, 2500);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    renderer.shadowMap.enabled=true;
    const controls = new OrbitControls(camera, renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 1);
    //scene.add(ambientLight);


    function helper(light) {
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        light.shadow.camera.top = 900;
        light.shadow.camera.bottom = -900;
        light.shadow.camera.left = -900;
        light.shadow.camera.right = 900;
        light.shadow.camera.near = 0.1;
        light.shadow.camera.far = 5000;
    }

    const directionalLight2 = new THREE.DirectionalLight( "white", 1 );
    directionalLight2.castShadow = true;
    directionalLight2.position.set(0, 600,-500);
    helper(directionalLight2);
    scene.add(directionalLight2);

    const directionalLight1 = new THREE.DirectionalLight( "white", 1 );
    directionalLight1.castShadow = true;
    directionalLight1.position.set(0, 600,500);
    helper(directionalLight1);
    scene.add(directionalLight1);

    const directionalLight3 = new THREE.DirectionalLight( "white", 1 );
    directionalLight3.castShadow = true;
    directionalLight3.position.set(500, 500,0);
    helper(directionalLight3);
    scene.add(directionalLight3);

    const directionalLight4 = new THREE.DirectionalLight( "white", 1 );
    directionalLight4.castShadow = true;
    directionalLight4.position.set(-500, 500,0);
    helper(directionalLight4);
    scene.add(directionalLight4);

    const plane = new THREE.PlaneGeometry(3500, 3500, 3);
    const planeMaterial = new THREE.MeshStandardMaterial({ color: "gray", side: THREE.DoubleSide });
    const planeMesh = new THREE.Mesh(plane, planeMaterial);
    scene.add(planeMesh);
 planeMesh.rotation.set(Math.PI / 2, 0, 0);
    planeMesh.position.set(0, -350, 0);
    planeMesh.receiveShadow = true;



    let parentWidth = 350, parentHeight = 500;
    if (parentWidth < 350) parentWidth = 350;
    if (parentHeight < 800) parentHeight = 800;
    let biasing = 10;
    let val = 0;
    if (parentWidth < 400) {
        val = (parentWidth - 400) / 2;
    }
    let val2 = 0;
    if (parentWidth > 400) val2 = parentWidth - 400;
    let changedParentWidth = (parentWidth - 100) / 2;
    let changedParentHeight = parentHeight - 900;
    let handleHeight = 400
    //let keyHoleMid = parentWidth / 2;
    let keyHoleMid = 50;
    //#region Handle BackPlate
    const parentShape = new THREE.Shape();
    parentShape.moveTo(0, 0);
    parentShape.absarc(parentWidth / 2, 0, parentWidth / 2, Math.PI, Math.PI * 2, false);
    // parentShape.lineTo(parentWidth, 0);
    parentShape.lineTo(parentWidth, parentHeight);
    parentShape.absarc(parentWidth / 2, parentHeight, parentWidth / 2, 0, Math.PI, false);
    // parentShape.lineTo(0, parentHeight);
    parentShape.lineTo(0, 0);

    const keyHoleWidth = 33.33, keyHoleHeight = 100;
    const keyHoleShape = new THREE.Shape();
    keyHoleShape.moveTo(-keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight);
    keyHoleShape.absarc(keyHoleMid + changedParentWidth, keyHoleHeight, keyHoleWidth / 2, Math.PI, Math.PI * 2, false);
    keyHoleShape.lineTo(keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight);
    keyHoleShape.lineTo(keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight + 100 - biasing);
    keyHoleShape.absarc(keyHoleMid + changedParentWidth, keyHoleHeight + 100, keyHoleWidth / 2 + biasing, 0, Math.PI, false);
    keyHoleShape.lineTo(-keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight + 100 - biasing);
    keyHoleShape.lineTo(-keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight);
    parentShape.holes.push(keyHoleShape);

    const bottomHole = new THREE.Path();
    bottomHole.absarc(parentWidth / 2, -50, 30, 0, Math.PI * 2, false);

    parentShape.holes.push(bottomHole);

    const topHole = new THREE.Path();
    topHole.absarc(parentWidth / 2, parentHeight, 30, 0, Math.PI * 2, false);

    parentShape.holes.push(topHole);

    const middleHole = new THREE.Path();
    middleHole.absarc(parentWidth / 2, parentHeight - 250, 15, 0, Math.PI * 2, false);

    parentShape.holes.push(middleHole);

    const extrudeSettings = {
        depth: 50,
        bevelEnabled: false
    };
    const parentGeometry = new THREE.ExtrudeGeometry(parentShape, extrudeSettings);
    const parentMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const parentMesh = new THREE.Mesh(parentGeometry, parentMaterial);
    scene.add(parentMesh);
    parentMesh.castShadow=true;
    parentMesh.receiveShadow=true;

    const parentEdges = new THREE.EdgesGeometry(parentGeometry);
    const parentEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const parentEdgesMesh = new THREE.LineSegments(parentEdges, parentEdgesMaterial);
    parentMesh.add(parentEdgesMesh);
    //#endregion

    let slideHandleWidth = 900;
    const slideHnadleShape = new THREE.Shape();
    slideHnadleShape.moveTo(0, -10);

    //slideHnadleShape.bezierCurveTo(0,0,slideHandleWidth/2, -5*biasing, slideHandleWidth, 0);

    //slideHnadleShape.lineTo(slideHandleWidth, 0);
    // slideHnadleShape.lineTo(slideHandleWidth, 100);
    slideHnadleShape.lineTo(100 + val / 4, -10);
    //slideHnadleShape.lineTo(100,100);

    slideHnadleShape.bezierCurveTo(100 + val / 4, -10, 100 - 5 * biasing + val / 4, 200, 100 + val / 4, 200);

    //slideHnadleShape.lineTo(100,300);
    slideHnadleShape.lineTo(-50, 200);
    slideHnadleShape.lineTo(-50, 100);
    slideHnadleShape.lineTo(0, -10);

    const slideHandleSettings = {
        depth: 100,
        bevelEnabled: false
    };

    const slideHandleGeometry = new THREE.ExtrudeGeometry(slideHnadleShape, slideHandleSettings);
    const slideHandleMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const slideHandleMesh = new THREE.Mesh(slideHandleGeometry, slideHandleMaterial);
    scene.add(slideHandleMesh);
    slideHandleMesh.castShadow=true;
    slideHandleMesh.receiveShadow=true;

    slideHandleMesh.position.set(0 - (parentWidth - 400) / 10, 100, 0);

    const slideHandleEdges = new THREE.EdgesGeometry(slideHandleGeometry);
    const slideHandleEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const slideHandleEdgesMesh = new THREE.LineSegments(slideHandleEdges, slideHandleEdgesMaterial);
    slideHandleMesh.add(slideHandleEdgesMesh);

    const slideHandleJoin = new THREE.Shape();
    slideHandleJoin.moveTo(0, 40);
    slideHandleJoin.bezierCurveTo(0, 40, 0, 0, -60, 0);
    slideHandleJoin.lineTo(-60, 20);
    slideHandleJoin.bezierCurveTo(-60, 20, -20, 20, -20, 40);
    slideHandleJoin.lineTo(0, 40);

    const slideHandleJoinSettings = {
        depth: 20,
        bevelEnabled: false
    };

    const slideHandleJoinGeometry = new THREE.ExtrudeGeometry(slideHandleJoin, slideHandleJoinSettings);
    const slideHandleJoinMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const slideHandleJoinMesh = new THREE.Mesh(slideHandleJoinGeometry, slideHandleJoinMaterial);
    scene.add(slideHandleJoinMesh);
    slideHandleJoinMesh.castShadow=true;
    slideHandleJoinMesh.receiveShadow=true;

    slideHandleJoinMesh.scale.set(5 + val / 62.5, 5 + val / 62.5, 5);
    slideHandleJoinMesh.position.set(200 + val / 2 + (val2 - 50) / 2 - (parentWidth - 500) / 10, 100 + handleHeight, 575 + val - (val / 2.5));
    slideHandleJoinMesh.rotation.set(Math.PI / 2, 0, -Math.PI);

    const slideHandleJoinEdges = new THREE.EdgesGeometry(slideHandleJoinGeometry);
    const slideHandleJoinEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const slideHandleJoinEdgesMesh = new THREE.LineSegments(slideHandleJoinEdges, slideHandleJoinEdgesMaterial);
    slideHandleJoinMesh.add(slideHandleJoinEdgesMesh);


    const slideHandleTop = new THREE.Shape();
    slideHandleTop.moveTo(-75 - val, 350);
    slideHandleTop.lineTo(150, 350);
    slideHandleTop.lineTo(175, 400);
    slideHandleTop.lineTo(175, 450);
    slideHandleTop.lineTo(-100 - val, 450);
    slideHandleTop.lineTo(-100 - val, 400);
    slideHandleTop.lineTo(-75 - val, 350);

    const slideHandleTopSettings = {
        depth: 100,
        bevelEnabled: false
    };

    const slideHandleTopGeometry = new THREE.ExtrudeGeometry(slideHandleTop, slideHandleTopSettings);
    const slideHandleTopMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const slideHandleTopMesh = new THREE.Mesh(slideHandleTopGeometry, slideHandleTopMaterial);
    slideHandleMesh.add(slideHandleTopMesh);
    slideHandleTopMesh.castShadow=true;
    slideHandleTopMesh.receiveShadow=true;

    //slideHandleTopMesh.position.set(0,300,0);

    const slideHandleTopEdges = new THREE.EdgesGeometry(slideHandleTopGeometry);
    const slideHandleTopEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const slideHandleTopEdgesMesh = new THREE.LineSegments(slideHandleTopEdges, slideHandleTopEdgesMaterial);
    slideHandleTopMesh.add(slideHandleTopEdgesMesh);

    const slideHandleBottomShape = new THREE.Shape();
    slideHandleBottomShape.moveTo(0, 0);
    slideHandleBottomShape.bezierCurveTo(0, 0, slideHandleWidth / 2, -5 * biasing, slideHandleWidth, 0);
    slideHandleBottomShape.lineTo(slideHandleWidth, 0);
    slideHandleBottomShape.lineTo(slideHandleWidth, 100);

    slideHandleBottomShape.bezierCurveTo(slideHandleWidth, 100, (slideHandleWidth - 100) / 2, 15 * biasing, 0, 100);

    slideHandleBottomShape.lineTo(0, 100);
    slideHandleBottomShape.lineTo(0, 0);

    const slideHandleBottomSettings = {
        depth: 100,
        bevelEnabled: false
    };

    const slideHandleBottomGeometry = new THREE.ExtrudeGeometry(slideHandleBottomShape, slideHandleBottomSettings);
    const slideHandleBottomMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const slideHandleBottomMesh = new THREE.Mesh(slideHandleBottomGeometry, slideHandleBottomMaterial);
    slideHandleMesh.add(slideHandleBottomMesh);
    slideHandleBottomMesh.castShadow=true;
    slideHandleBottomMesh.receiveShadow=true;

    slideHandleTopMesh.position.set(-(parentWidth - 150) / 10, -30, 0);

    const slideHandleBottomEdges = new THREE.EdgesGeometry(slideHandleBottomGeometry);
    const slideHandleBottomEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const slideHandleBottomEdgesMesh = new THREE.LineSegments(slideHandleBottomEdges, slideHandleBottomEdgesMaterial);
    slideHandleBottomMesh.add(slideHandleBottomEdgesMesh);

    slideHandleBottomMesh.rotation.set(-Math.PI / 2, 0, 0);
    let val3 = 0;
    if (parentWidth > 750) val3 = parentWidth - 750;
    slideHandleBottomMesh.position.set(250 - val3 / 20, -100, 100);

    //slideHandleBottomMesh.rotation.set(0,0,0);

    const group = new THREE.Group();
    group.add(slideHandleMesh);
    // group.add(slideHandleJoinMesh);
    group.add(slideHandleBottomMesh);
    group.add(slideHandleTopMesh);
    scene.add(group);

    group.rotation.set(-Math.PI / 2, 0, 0);
    group.position.set(parentWidth / 2, handleHeight, 470);

    function rotateHandle(isHandleRotated) {
        if (isHandleRotated) {
            group.rotation.set(-Math.PI / 2, -Math.PI, 0);
            group.position.set(parentWidth / 2, parentHeight - 300, 450);
            slideHandleJoinMesh.rotation.set(-Math.PI / 2, 0, 0);
            slideHandleJoinMesh.position.set(parentWidth / 2 + parentWidth / 13, 400, 550);
        }
    }
    rotateHandle(false);

    const screw = new THREE.Shape();
    screw.moveTo(0, 3);
    screw.absarc(0.5, 3, 0.5, Math.PI, Math.PI * 2, false);
    //screw.lineTo(1,3);
    screw.absarc(1, 3.5, 0.5, 3 * (Math.PI / 2), Math.PI / 2, false);
    //screw.lineTo(1,4);
    screw.absarc(0, 4, 0.5, 0, Math.PI, false);
    //screw.lineTo(0,4);
    screw.absarc(0, 3.5, 0.5, Math.PI / 2, 3 * (Math.PI / 2), false);
    screw.lineTo(0, 3);

    const screwGeometry = new THREE.ExtrudeGeometry(screw);
    const screwMaterial = new THREE.MeshPhysicalMaterial({ color: "gray", emissive: "gray" });
    const screwMesh = new THREE.Mesh(screwGeometry, screwMaterial);
    //scene.add(screwMesh);
    screwMesh.scale.set(8, 8, 8);
    screwMesh.position.set(parentWidth / 2, -80, 50);

    const screw2 = new THREE.Shape();
    screw2.moveTo(0, 3);
    screw2.absarc(0.5, 3, 1, Math.PI, Math.PI * 2, false);
    screw2.lineTo(1, 3);
    screw2.absarc(1, 3.5, 1, 3 * (Math.PI / 2), Math.PI / 2, false);
    screw2.lineTo(1, 4);
    screw2.absarc(0, 4, 1, 0, Math.PI, false);
    screw2.lineTo(0, 4);
    screw2.absarc(0, 3.5, 1, Math.PI / 2, 3 * (Math.PI / 2), false);
    screw2.lineTo(0, 3);

    const screwGeometry2 = new THREE.ExtrudeGeometry(screw2);
    const screwMaterial2 = new THREE.MeshPhysicalMaterial({ color: "black", emissive: "black" });
    const screwMesh2 = new THREE.Mesh(screwGeometry2, screwMaterial2);
    //scene.add(screwMesh2);
    screwMesh2.scale.set(8, 8, 8);
    screwMesh2.position.set(parentWidth / 2, parentHeight - 30, 50);

    // Animating the shape
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
}



project2();
