import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { emissive } from 'three/tsl';

function project1() {
    //Setting scene, camera and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 0, 1500);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    renderer.shadowMap.enabled = true;
    const controls = new OrbitControls(camera, renderer.domElement);

    function helper(light) {
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        light.shadow.camera.top = 600;
        light.shadow.camera.bottom = -600;
        light.shadow.camera.left = -600;
        light.shadow.camera.right = 600;
        light.shadow.camera.near = 0.1;
        light.shadow.camera.far = 4000;
    }

    const directionalLight1 = new THREE.DirectionalLight( "white", 1 );
    directionalLight1.castShadow = true;
    directionalLight1.position.set(200, 0, 300);
    helper(directionalLight1);
    // scene.add(directionalLight1);

    const directionalLight2 = new THREE.PointLight( "white", 1000000000 );
    directionalLight2.castShadow = true;
    directionalLight2.position.set(0, 100,-500);
    // directionalLight2.target.position.set(100,-550,400);
    // scene.add(directionalLight2.target);
    helper(directionalLight2);
    scene.add(directionalLight2);

    const directionalLight3 = new THREE.DirectionalLight( "white", 4 );
    directionalLight3.castShadow = false;
    directionalLight3.position.set(-400, 0, 400);
    helper(directionalLight3);
    // scene.add(directionalLight3);

    const directionalLight4 = new THREE.DirectionalLight( "white", 4 );
    directionalLight4.castShadow = true;
    directionalLight4.position.set(400, 0, 50);
    helper(directionalLight4);
    // scene.add(directionalLight4);

    const directionalLight5 = new THREE.DirectionalLight( "white", 4 );
    directionalLight5.castShadow = true;
    directionalLight5.position.set(100, 0, -300);
    helper(directionalLight5);
    // scene.add(directionalLight5);

    const directionalLight6 = new THREE.DirectionalLight( "white", 4 );
    directionalLight6.castShadow = true;
    directionalLight6.position.set(30, -500, 10);
    helper(directionalLight6);
    // scene.add(directionalLight6);

   const pointLightHelper = new THREE.PointLightHelper(directionalLight2 , 30)
   scene.add(pointLightHelper)

    const plane = new THREE.PlaneGeometry(1500, 1500, 3);
    const planeMaterial = new THREE.MeshStandardMaterial({ color: "gray", side: THREE.DoubleSide });
    const planeMesh = new THREE.Mesh(plane, planeMaterial);
    scene.add(planeMesh);
    // planeMesh.rotation.set(Math.PI / 2, 0, 0);
    planeMesh.position.set(0, -50, 200);
    planeMesh.receiveShadow = true;

    let parentWidth = 100, parentHeight = 800;
    if (parentWidth < 100) parentWidth = 100;
    if (parentHeight < 800) parentHeight = 800;
    let biasing = 10;
    let changedParentWidth = (parentWidth - 100) / 2;
    let changedParentHeight = parentHeight - 900;
    let keyHoleMid = 50;
    //#region Handle BackPlate
    const parentShape = new THREE.Shape();
    parentShape.moveTo(0, 0);
    parentShape.absarc(parentWidth / 2, 0, parentWidth / 2, Math.PI, Math.PI * 2, false);
    parentShape.lineTo(parentWidth, parentHeight);
    parentShape.absarc(parentWidth / 2, parentHeight, parentWidth / 2, 0, Math.PI, false);
    parentShape.lineTo(0, 0);

    const keyHoleWidth = 33.33, keyHoleHeight = 200;
    const keyHoleShape = new THREE.Shape();
    keyHoleShape.moveTo(-keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight);
    keyHoleShape.absarc(keyHoleMid + changedParentWidth, keyHoleHeight, keyHoleWidth / 2, Math.PI, Math.PI * 2, false);
    keyHoleShape.lineTo(keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight);
    keyHoleShape.lineTo(keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight + 100 - biasing);
    keyHoleShape.absarc(keyHoleMid + changedParentWidth, keyHoleHeight + 100, keyHoleWidth / 2 + biasing, 0, Math.PI, false);
    keyHoleShape.lineTo(-keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight + 100 - biasing);
    keyHoleShape.lineTo(-keyHoleWidth / 2 + keyHoleMid + changedParentWidth, keyHoleHeight);
    parentShape.holes.push(keyHoleShape);
    const extrudeSettings = {
        depth: 50,
        bevelEnabled: false
    };
    const parentGeometry = new THREE.ExtrudeGeometry(parentShape, extrudeSettings);
    const parentMaterial = new THREE.MeshStandardMaterial({ color: "gray", side: THREE.DoubleSide, emissive: "gray" });
    const parentMesh = new THREE.Mesh(parentGeometry, parentMaterial);
    scene.add(parentMesh);
    parentMesh.castShadow = true;
    parentMesh.receiveShadow=true;
    parentMesh.rotation.set(0,0,0)

    const parentEdges = new THREE.EdgesGeometry(parentGeometry);
    const parentEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const parentEdgesMesh = new THREE.LineSegments(parentEdges, parentEdgesMaterial);
    parentMesh.add(parentEdgesMesh);
    //#endregion

    //#region Handle Geometry
    let handleWidth = 100;
    const handlePoints = [
        new THREE.Vector3(0, 0 - changedParentWidth, -50),
        new THREE.Vector3(0, 0 - changedParentWidth, 0),
        new THREE.Vector3(-handleWidth, 0 - changedParentWidth, 0),
        new THREE.Vector3(-handleWidth, 900 - 100 + changedParentWidth + changedParentHeight, 0),
        new THREE.Vector3(0, 900 - 100 + changedParentWidth + changedParentHeight, 0),
        new THREE.Vector3(0, 900 - 100 + changedParentWidth + changedParentHeight, -50)
    ];
    const handlePath = new THREE.CatmullRomCurve3(handlePoints);
    const handleGeometry = new THREE.TubeGeometry(
        handlePath,
        100,
        20,
        8,
        false
    );
    const material = new THREE.MeshPhysicalMaterial({ color: "gray", side: THREE.DoubleSide, roughness: 0.2, emissive: "gray" });
    const handleMesh = new THREE.Mesh(handleGeometry, material);
    handleMesh.position.set(parentWidth / 2, 50, 100);
    handleMesh.castShadow=true;
    handleMesh.receiveShadow=true;
    parentMesh.add(handleMesh);

    const handleEdges = new THREE.EdgesGeometry(handleGeometry);
    const handleEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const handleEdgesMesh = new THREE.LineSegments(handleEdges, handleEdgesMaterial);
    //handleMesh.add(handleEdgesMesh);

    function rotateHandle(isHandleRotated) {
        if (isHandleRotated) {
            handleMesh.rotation.set(Math.PI, -Math.PI, 0);
            handleMesh.position.set(parentWidth / 2, parentHeight - 50, 100);
        }
    }

    rotateHandle(false);
    //#endregion

    //#region knob Geometry
    let knobHeight = 450;
    const knob = new THREE.Shape();
    knob.moveTo(keyHoleMid - 20 + changedParentWidth, 0);
    knob.absarc(keyHoleMid + changedParentWidth, 0, 20, Math.PI, Math.PI * 2, false);
    knob.lineTo(keyHoleMid + 20 + changedParentWidth, 0);
    knob.lineTo(keyHoleMid + 20 + biasing + changedParentWidth, 200);
    knob.absarc(keyHoleMid + changedParentWidth, 200, keyHoleMid / 2 + biasing / 2, 0, Math.PI, false);
    knob.lineTo(keyHoleMid - 20 - biasing + changedParentWidth, 200);
    knob.lineTo(keyHoleMid - 20 + changedParentWidth, 0);

    const knobSettings = {
        depth: 50,
        bevelEnabled: false
    };

    const knobGeometry = new THREE.ExtrudeGeometry(knob, knobSettings);
    const knobMaterial = new THREE.MeshPhysicalMaterial({ color: "red", side: THREE.DoubleSide, emissive: "red" });
    const knobMesh = new THREE.Mesh(knobGeometry, knobMaterial);
    knobMesh.position.set(0, knobHeight, 50);
    knobMesh.castShadow=true;
    parentMesh.add(knobMesh);
    parentMesh.position.set(0, -400, 0);

    const knobEdges = new THREE.EdgesGeometry(knobGeometry);
    const knobEdgesMaterial = new THREE.LineBasicMaterial({ color: "white" });
    const knobEdgesMesh = new THREE.LineSegments(knobEdges, knobEdgesMaterial);
    knobMesh.add(knobEdgesMesh);
    //#endregion

    // Animating the shape
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
}

project1();
