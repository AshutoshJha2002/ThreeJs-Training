import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { emissive, or } from 'three/tsl';
//import BufferGeometryUtils from "https://cdn.jsdelivr.net/npm/three@0.125.2/examples/jsm/utils/BufferGeometryUtils.js";
function task2() {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 80, 5);
    const renderer = new THREE.WebGLRenderer();
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    function helper(light) {
        light.castShadow = true;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        light.shadow.camera.top = 60;
        light.shadow.camera.bottom = -60;
        light.shadow.camera.left = -60;
        light.shadow.camera.right = 60;
        light.shadow.camera.near = 0.1;
        light.shadow.camera.far = 1000;
    }

    //For Directional Light and Ambient Light
    function lig1(param1) {
        let light;
        if (param1 === "AmbientLight")
            light = new THREE.AmbientLight(0xffffff, 5);
        else light = new THREE.DirectionalLight(0xffffff, 5);
        //const light = new param1(0xffffff, 5);
        light.position.set(-25, 40, 0);
        if (light.isDirectionalLight) {
            helper(light);
        }
        return light;
    }

    function getMesh(param2, param1) {
        console.log(param2);
        if (param2 === "PlaneGeometry") {
            const geometry = new THREE.PlaneGeometry(10, 10);
            const material = new param1({ color: 0x808080, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(geometry, material);
            plane.position.set(0, 0, 0);
            plane.rotation.set(-Math.PI / 2, 0, 0);
            plane.scale.set(10, 10, 1);
            plane.receiveShadow = true;
            return plane;
            //scene.add(plane);
        }
        if (param2 === "BoxGeometry") {
            const geometry1 = new THREE.BoxGeometry(10, 10, 10);
            const material1 = new param1({ color: 'red', side: THREE.DoubleSide, emissive: "red" });
            const cube1 = new THREE.Mesh(geometry1, material1);
            cube1.position.set(0, 13, 0);
            cube1.castShadow = true;
            cube1.receiveShadow = true;
            //scene.add(cube1);
            return cube1;
        }
        if (param2 === "CapsuleGeometry") {
            const geometry2 = new THREE.CapsuleGeometry(5, 10, 32, 32);
            const material1 = new param1({ color: 'red', side: THREE.DoubleSide, emissive: "red" });
            const cube2 = new THREE.Mesh(geometry2, material1);
            cube2.position.set(27, 13, 0);
            cube2.castShadow = true;
            cube2.receiveShadow = true;
            //scene.add(cube2);
            return cube2;
        }
        if (param2 === "CylinderGeometry") {
            const material1 = new param1({ color: 'red', side: THREE.DoubleSide, emissive: "red" });
            const geometry3 = new THREE.CylinderGeometry(5, 5, 10, 32);
            const cube3 = new THREE.Mesh(geometry3, material1);
            cube3.position.set(-27, 13, 0);
            cube3.castShadow = true;
            cube3.receiveShadow = true;
            //scene.add(cube3);
            return cube3;
        }
    }

    //For Plane and Cube with variable material
    function obj(param1) {
        scene.add(getMesh("PlaneGeometry", param1));
        scene.add(getMesh("BoxGeometry", param1));
        scene.add(getMesh("CapsuleGeometry", param1));
        scene.add(getMesh("CylinderGeometry", param1));
        /*const geometry = new THREE.PlaneGeometry(10, 10);
        const material = new param1({ color: 0x808080, side: THREE.DoubleSide });
        const plane = new THREE.Mesh(geometry, material);
        plane.position.set(0, 0, 0);
        plane.rotation.set(-Math.PI / 2, 0, 0);
        plane.scale.set(10, 10, 1);
        plane.receiveShadow = true;
        scene.add(plane);

        const geometry1 = new THREE.BoxGeometry(10, 10, 10);
        const material1 = new param1({ color: 'red', side: THREE.DoubleSide, emissive: "red" });
        const cube1 = new THREE.Mesh(geometry1, material1);
        cube1.position.set(0, 13, 0);
        cube1.castShadow = true;
        cube1.receiveShadow = true;
        scene.add(cube1);

        const geometry2 = new THREE.CapsuleGeometry(5, 10, 32, 32);
        const cube2 = new THREE.Mesh(geometry2, material1);
        cube2.position.set(27, 13, 0);
        cube2.castShadow = true;
        cube2.receiveShadow = true;
        scene.add(cube2);

        const geometry3 = new THREE.CylinderGeometry(5, 5, 10, 32);
        const cube3 = new THREE.Mesh(geometry3, material1);
        cube3.position.set(-27, 13, 0);
        cube3.castShadow = true;
        cube3.receiveShadow = true;
        scene.add(cube3);*/
    }

    //For Spot Light and Point Light
    function lig2(param1) {
        let light;
        if (param1 === "SpotLight")
            light = new THREE.SpotLight(0xffffff, 5, 400);
        else light = new THREE.PointLight(0xffffff, 5, 400);
        light.position.set(3, 50, 10);
        light.decay = 0.1;
        light.castShadow = true;

        helper(light);
        return light;
    }

    function getLight(str) {
        if (str === "AmbientLight" || str === "DirectionalLight") return lig1(str);
        else if (str === "PointLight" || str === "SpotLight") return lig2(str);
    }

    //lig1(THREE.AmbientLight);
    //obj(THREE.MeshStandardMaterial);

    function removeObj() {
        while (scene.children.length > 0) {
            console.log(scene.children[0]);
            let child = scene.children[0];
            if (child.geometry) {
                child.geometry.dispose();
            }
            if (child.material) {
                child.material.dispose();
            }
            scene.remove(child);
        }
    }

    function eventHandler(event) {
        removeObj();
        if (event.key === "1") {
            scene.add(getLight("AmbientLight"));
            //lig1(THREE.AmbientLight);
            obj(THREE.MeshBasicMaterial);
        }
        else if (event.key === "2") {
            scene.add(getLight("PointLight"));
            //lig2(THREE.PointLight);
            obj(THREE.MeshStandardMaterial);
        }
        else if (event.key === "3") {
            scene.add(getLight("DirectionalLight"));
            //lig1(THREE.DirectionalLight);
            obj(THREE.MeshStandardMaterial);
        }
        else if (event.key === "4") {
            scene.add(getLight("SpotLight"));
            //lig2(THREE.SpotLight);
            obj(THREE.MeshPhongMaterial);
        }
        else if (event.key === "5") {
            scene.add(getLight("PointLight"));
            //lig2(THREE.PointLight);
            obj(THREE.MeshPhongMaterial);
        }
        else if (event.key === "6") {
            scene.add(getLight("AmbientLight"));
            //lig1(THREE.AmbientLight);
            obj(THREE.MeshPhongMaterial);
        }
        else if (event.key === "7") {
            scene.add(getLight("AmbientLight"));
            //lig1(THREE.AmbientLight);
            obj(THREE.MeshPhysicalMaterial);
        }
        else if (event.key === "8") {
            scene.add(getLight("DirectionalLight"));
            //lig1(THREE.DirectionalLight);
            obj(THREE.MeshPhysicalMaterial);
        }
        else if (event.key === "9") {
            scene.add(getLight("PointLight"));
            //lig2(THREE.PointLight);
            obj(THREE.MeshPhysicalMaterial);
        }
    }

    document.addEventListener("keyup", eventHandler);

    renderer.setSize(window.innerWidth, window.innerHeight);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false;
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
}

function task3() {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, -3);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);

    /*const geometry = new THREE.PlaneGeometry(1,1);
    const material=new THREE.MeshBasicMaterial({color:"red", side: THREE.DoubleSide});
    const plane=new THREE.Mesh(geometry, material);
    plane.rotation.set(-Math.PI/2,0,0);
    plane.scale.set(1,1,1);
    plane.position.set(0,0,0);
    scene.add(plane);*/

    const length = 0.6, height = 1.2;
    const shape = new THREE.Shape();
    shape.moveTo(0, 0);
    shape.lineTo(0, height);
    shape.lineTo(length, height);
    shape.lineTo(length, 0);
    shape.lineTo(0, 0);

    // Create a single circular hole
    const holeRadius = 0.02;
    let arrX = [0.125, 0.25, 0.375];
    let arrY = [0.1, 0.2];
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 2; j++) {
            const hole = new THREE.Path();
            let corX = (length / 4) * (i + 1);
            let corY = (height / 3) * (j + 1);
            hole.absarc(corX, corY, holeRadius, 0, Math.PI * 2, false);
            shape.holes.push(hole);
        }
    }

    const extrudeSettings = {
        depth: 0.001,
        bevelEnabled: false
    };
    const geometry1 = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    const material1 = new THREE.MeshBasicMaterial({ color: "red", side: THREE.DoubleSide });
    const rect = new THREE.Mesh(geometry1, material1);
    scene.add(rect);
    rect.position.set(0, 0, 0);
    rect.rotation.y = Math.PI / 36;
    //rect.rotation.z=Math.PI/36;

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
}


function task4() {
    const scene = new THREE.Scene();
    let aspect = window.innerWidth / Window.innerHeight;
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    //const camera = new THREE.OrthographicCamera(-400*aspect, 400*aspect,400,-400, 0.1, 3000);
    camera.position.set(0, 0, 900);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);


    let origin = new THREE.Vector2(0, 0);
    /*function createShape(width, height) {
        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.lineTo(0, height);
        shape.lineTo(width, height);
        shape.lineTo(width, 0);
        shape.lineTo(0, 0);
        //const geometry=new THREE.ShapeGeometry(shape);
        return shape;
    }

    function helper(width, ax) {
        let line;
        if (ax === "X") {
            line = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(width, width, 0));
        }
        else if (ax === "Y") {
            line = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, width, 0));
        }
        else line = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, width));
        const extrudeSettings = {
            bevelEnabled: false,
            extrudePath: line
        };
        const shape = createShape(40, 40);
        const s = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const material = new THREE.MeshBasicMaterial({ color: "green", side: THREE.DoubleSide });
        const m = new THREE.Mesh(s, material);
        return m;
    }
    scene.add(helper(100,"X"));*/
    let width = 100, height = 100;

    const shape = new THREE.Shape();
    shape.moveTo(-width / 2 + origin.x, -height / 2 + origin.y);
    shape.lineTo(origin.x, -height / 2 + origin.y);
    shape.lineTo(origin.x, -height + origin.y);
    shape.lineTo(width / 4 + origin.x, -height + origin.y);
    shape.lineTo(width / 4 + origin.x, -height / 2 + origin.y);
    shape.lineTo(width / 2 + origin.x, -height / 2 + origin.y);
    shape.lineTo(width / 2 + origin.x, origin.y);
    shape.lineTo(width + origin.x, origin.y);
    shape.lineTo(width + origin.x, height / 4 + origin.y);
    shape.lineTo(width / 2 + origin.x, height / 4 + origin.y);
    shape.lineTo(width / 2 + origin.x, height / 2 + origin.y);
    shape.lineTo(origin.x, height / 2 + origin.y);
    shape.lineTo(origin.x, height + origin.y);
    shape.lineTo(origin.x - width / 4, origin.y + height);
    shape.lineTo(origin.x - width / 4, origin.y + height / 2);
    shape.lineTo(-width / 2 + origin.x, height / 2 + origin.y);
    shape.lineTo(-width / 2 + origin.x, origin.y);
    shape.lineTo(-width + origin.x, origin.y);
    shape.lineTo(-width + origin.x, origin.y - height / 4);
    shape.lineTo(-width / 2 + origin.x, origin.y - height / 4)
    shape.lineTo(-width / 2 + origin.x, -height / 2 + origin.y);

    /*const circleShape=new THREE.Shape();
    circleShape.moveTo(100,0);
    circleShape.absarc(0,0,100,0,Math.PI*2,false);
    const Cirgeometry=new THREE.ShapeGeometry(circleShape);
    const cirMaterial=new THREE.MeshBasicMaterial({color: "green", side: THREE.DoubleSide});
    const circle=new THREE.Mesh(Cirgeometry,cirMaterial);
    circle.position.set(0,0,0);
    //scene.add(circle);
    */

    //how to know about origin
    const axesHelper = new THREE.AxesHelper(500);
    scene.add(axesHelper);


    //Degree to radian
    function getTan(height) {
        const degree = 60;
        const degRad = THREE.MathUtils.degToRad(degree);
        let val = height * (Math.tan(degRad));
        return val;
    }
    //CatmullRom Curve
    /*const pathPoints = [
        new THREE.Vector3(origin.x, origin.y, 0),
        new THREE.Vector3(origin.x + val, origin.y + 100, 0),
        new THREE.Vector3(origin.x + 100, origin.y, 0),
        new THREE.Vector3(origin.x + 900, origin.y, 0),
        new THREE.Vector3(origin.x + (1000-val), origin.y + 100, 0),
        new THREE.Vector3(origin.x + 1000, origin.y, 0)
    ];*/

    let extrudeWidth = 1000;
    let vertex1 = new THREE.Vector3(0, 0, 0);
    let vertex2 = new THREE.Vector3(extrudeWidth, 0, 0);
    const p = new THREE.LineCurve3(vertex1, vertex2);

    //const path = new THREE.CatmullRomCurve3(pathPoints, false);

    const extrudeSettings = {
        bevelEnabled: false,
        extrudePath: p
    };

    const geometry1 = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    const material1 = new THREE.MeshBasicMaterial({ color: "red", wireframe: false });
    const rect = new THREE.Mesh(geometry1, material1);
    scene.add(rect);

    //Method 2
    const pointsArray = geometry1.attributes.position;
    //console.log(pointsArray.array.length);
    /*let tri=[];
    console.log(pointsArray);
for(let i=0;i<pointsArray.array.length;i+=3)
{
    //pointsArray[i]=0;
let v=[];
v.push(pointsArray.array[i]);
v.push(pointsArray.array[i+1]);
v.push(pointsArray.array[i+2]);
tri.push(v);
}
        function multiDimensionalUnique(arr) {
            var uniques = [];
            var itemsFound = {};
            for(var i = 0, l = arr.length; i < l; i++) {
                var stringified = JSON.stringify(arr[i]);
                if(itemsFound[stringified]) { continue; }
                uniques.push(arr[i]);
                itemsFound[stringified] = true;
            }
            return uniques;
        }
        //console.log(tri);
        tri=multiDimensionalUnique(tri);
        console.log(tri);
        for(let i=0;i<tri.length;i++)
            {
        //console.log(tri[i]);
                const pointPosition = new THREE.Vector3(tri[i][0], tri[i][1], tri[i][2]);   //tri[18];
                const pointGeometry = new THREE.BufferGeometry();
                pointGeometry.setFromPoints([pointPosition]);
                const pointMaterial = new THREE.PointsMaterial({ 
                    size: 20, // Adjust the size of the dot
                    color: "green" // Set the color of the dot
                });
                const pointMesh = new THREE.Points(pointGeometry, pointMaterial);
                scene.add(pointMesh);
            for(let j=0;j<4;j++)
            {
                let pointPosition;
                if(j>1) pointPosition=new THREE.Vector3(60, tri[j][1], tri[j][2]);
                else pointPosition = new THREE.Vector3(tri[j][0], tri[j][1], tri[j][2]);   //tri[18];
                const pointGeometry = new THREE.BufferGeometry();
                pointGeometry.setFromPoints([pointPosition]);
                const pointMaterial = new THREE.PointsMaterial({ 
                    size: 50, // Adjust the size of the dot
                    color: "blue" // Set the color of the dot
                });
                const pointMesh = new THREE.Points(pointGeometry, pointMaterial);
                scene.add(pointMesh);
            }
            }*/

    //Iterating over the vertices and modifying the coordinates
    //let vertex = new THREE.Vector3();
    //let vertex1 = new THREE.Vector3();
    //console.log(pointsArray.getX(200));
    for (let i = 0; i < pointsArray.count; i++) {
        //vertex.fromBufferAttribute(pointsArray, i);
        let temp = pointsArray.getX(i);
        let yCor = pointsArray.getY(i);
        //console.log(temp, vertex1.x);
        if (temp === vertex1.x) {
            let val = getTan(yCor - origin.y);
            pointsArray.setX(i, temp + val);
        }
        if (temp === vertex2.x) {
            let val = getTan(yCor - origin.y);
            pointsArray.setX(i, temp - val);
        }
        //console.log(vertex.fromBufferAttribute(pointsArray, i))
        /*if (vertex.x === vertex1.x) {
            let val = getTan(vertex.y-origin.y);
            vertex.x += val;
        }
        if (vertex.x === vertex2.x) {
            let val = getTan(vertex.y-origin.y);
            vertex.x -= val;
        }
        pointsArray.setXYZ(i, vertex.x, vertex.y, vertex.z);*/
    }
    geometry1.attributes.position.needsUpdate = true;

    /* //Method 1 using 2D Array
 let pointsArray=geometry1.attributes.position.array;
 //metry1.deleteAttribute('position');
 //geometry1.attributes.position.needsUpdate=true;
 //console.log(pointsArray);
 //console.log(pointsArray.length);

 console.log(geometry1.getAttribute('position'));
//const temp=geometry1.getAttribute('position');

 let tri=[];
 for(let i=0;i<pointsArray.length;i+=3)
 {
     //pointsArray[i]=0;
 let v=[];
 v.push(pointsArray[i]);
 v.push(pointsArray[i+1]);
 v.push(pointsArray[i+2]);
 tri.push(v);
 }
 pointsArray[18*3]=60;
 //pointsArray[35*3]=1000-60;
 //pointsArray[27*3+1]=160;
 //pointsArray[36*3+2]=-500;
 //pointsArray[]
 //pointsArray[27*3+1]=-pointsArray[27*3+1];
 //pointsArray[0*3+1]=50;
 //pointsArray[36*3]=60;
 //console.log(tri[0]);
 //console.log(pointsArray.length, tri.length,tri[18], pointsArray[20*3+0]);
 //console.log(tri[18]);
 var geometry = new THREE.BufferGeometry();
 geometry.setAttribute( 'position', new THREE.BufferAttribute( pointsArray, 3 ) );
 var material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
 var mesh = new THREE.Mesh( geometry, material );
 //geometry1.center();
 //scene.add(mesh);
 mesh.position.set(0,150,0);
 
 function multiDimensionalUnique(arr) {
     var uniques = [];
     var itemsFound = {};
     for(var i = 0, l = arr.length; i < l; i++) {
         var stringified = JSON.stringify(arr[i]);
         if(itemsFound[stringified]) { continue; }
         uniques.push(arr[i]);
         itemsFound[stringified] = true;
     }
     return uniques;
 }
 
 tri=multiDimensionalUnique(tri);

 for(let i=0;i<tri.length;i++)
 {
console.log(tri[i]);
     if(tri[i][0]===0){
     const pointPosition = new THREE.Vector3(tri[i][0], tri[i][1], tri[i][2]);   //tri[18];
     const pointGeometry = new THREE.BufferGeometry();
     pointGeometry.setFromPoints([pointPosition]);
     const pointMaterial = new THREE.PointsMaterial({ 
         size: 50, // Adjust the size of the dot
         color: "green" // Set the color of the dot
     });
     const pointMesh = new THREE.Points(pointGeometry, pointMaterial);
     scene.add(pointMesh);
 }
 for(let j=0;j<4;j++)
 {
     let pointPosition;
     if(j>1) pointPosition=new THREE.Vector3(60, tri[j][1], tri[j][2]);
     else pointPosition = new THREE.Vector3(tri[j][0], tri[j][1], tri[j][2]);   //tri[18];
     const pointGeometry = new THREE.BufferGeometry();
     pointGeometry.setFromPoints([pointPosition]);
     const pointMaterial = new THREE.PointsMaterial({ 
         size: 50, // Adjust the size of the dot
         color: "blue" // Set the color of the dot
     });
     const pointMesh = new THREE.Points(pointGeometry, pointMaterial);
     scene.add(pointMesh);
 }
 } */

    const edges = new THREE.EdgesGeometry(geometry1);
    const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    const edgeMesh = new THREE.LineSegments(edges, edgeMaterial);
    scene.add(edgeMesh);

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
}

function test1() {

    //Setting scene, camera and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 0, 2000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);

    //Creating the shape with varying width and height
    let width = 700, height = 800;
    let temp1=width/40;
    let temp2=height/50;
    const shape = new THREE.Shape();
    shape.moveTo(0, 0);
    shape.lineTo(0, -height * (3 / 25));
shape.bezierCurveTo(0,-(7*temp2),4*temp1,-12*temp2,6*temp1,-6*temp2);
    shape.lineTo(width * (3 / 20), 0);
shape.bezierCurveTo(26*temp1,0,32*temp1,0,28*temp1,-38*temp2);
    shape.lineTo(4 * width * (3 / 20) + (width / 10), -(6 * height * (3 / 25) + (height / 25)));
shape.bezierCurveTo(30*temp1,-40*temp2,32*temp1,-42*temp2,34*temp1,-38*temp2);
    shape.bezierCurveTo(32*temp1,6*temp2,36*temp1,6*temp2,6*temp1,6*temp2);
    shape.lineTo(width * (3 / 20), 2 * height * (3 / 25));
shape.bezierCurveTo(4*temp1,14*temp2,2*temp1,16*temp2,0,12*temp2);
    shape.lineTo(0, height * (3 / 25));
    shape.lineTo(-width * (3 / 20), height * (3 / 25));
shape.bezierCurveTo(-8*temp1,4*temp2,-10*temp1,2*temp2,-6*temp1,0);
    shape.lineTo(0, 0);

    //Creating the hole and pushing it into the shape
    let hole = new THREE.Path();
    hole.absarc((width * (3 / 20)) / 2, (height * (3 / 25)) / 2, 25, 0, Math.PI * 2, false);
    shape.holes.push(hole);
    
    // Extrusion along the width with variable extrudeWidth
    let extrudeWidth = 800;
    const line = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(extrudeWidth, 0, 0));
    const extrudeSettings = {
        bevelEnabled: false,
        depth: 100
        //extrudePath: line
    };

    //Creating extrude geometry
    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    const material = new THREE.MeshBasicMaterial({ color: "red", side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geometry, material);
    //geometry.rotateY(-Math.PI / 2);

    scene.add(mesh);

    //Setting color for the edges to make the edges visible
    const edges = new THREE.EdgesGeometry(geometry);
    const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    const edgeMesh = new THREE.LineSegments(edges, edgeMaterial);
    scene.add(edgeMesh);

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

}

test1();
//task3();
//task2();
//task4();
